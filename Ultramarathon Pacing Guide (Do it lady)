from datetime import datetime, date

# Get today's date string
today_str = date.today().strftime('%Y-%m-%d')

# Prompt the user
manual_input = input(f"Press Enter to use current time or enter start time manually (in YYYY-MM-DD HH:MM:SS format):")

if manual_input.strip():
    try:
        input_str = manual_input.strip()
        # If only time is entered
        if len(input_str) == 8 and ':' in input_str:
            input_str = f"{today_str} {input_str}"
        # Try parsing full datetime
        current_datetime = datetime.strptime(input_str, '%Y-%m-%d %H:%M:%S')
        print(f"âœ… Using manual start time: {current_datetime.strftime('%Y-%m-%d %H:%M:%S')}")
    except ValueError:
        print("âŒ Invalid format. Using current system time instead.")
        current_datetime = datetime.now()
else:
    current_datetime = datetime.now()
    print(f"ğŸ•’ Using current system time: {current_datetime.strftime('%Y-%m-%d %H:%M:%S')}")

# Convert to timestamp
current_timestamp = current_datetime.timestamp()


# Define cut-off time and convert to datetime object
cut_off_str = '2025-09-06 14:00:00'
cut_off_datetime = datetime.strptime(cut_off_str, '%Y-%m-%d %H:%M:%S')
cut_off_timestamp = cut_off_datetime.timestamp()
print(f"Cut-off time: {cut_off_datetime.strftime('%Y-%m-%d %H:%M:%S')}")

# Calculate time remaining
time_remaining_seconds = cut_off_timestamp - current_timestamp

if time_remaining_seconds <= 0:
    print("ğŸš« The cut-off time has already passed!")
else:
    # Get user input for start and end mileage
    start = input("What mile mark are you starting from?: ")
    end = input("What mile mark are you ending at?: ")

    try:
        start = float(start)
        end = float(end)
        mileage = end - start

        if mileage <= 0:
            print("âš ï¸ End mileage must be greater than start mileage.")
        else:
            # Break time remaining into hours and minutes
            total_minutes_remaining = int(time_remaining_seconds / 60)
            hours_remaining = total_minutes_remaining // 60
            minutes_remaining = total_minutes_remaining % 60

            # Calculate pace needed (min/mile)
            pace_needed = total_minutes_remaining / mileage
            pace_minutes = int(pace_needed)
            pace_seconds = int((pace_needed - pace_minutes) * 60)

            print(f"""
ğŸƒâ€You are running {mileage:.2f} miles, starting at mile {start} and ending at mile {end}.
ğŸ•’ Time remaining until cut-off: {hours_remaining} hours, {minutes_remaining} minutes
â±ï¸ Required pace: {pace_minutes}:{pace_seconds:02d} minutes/mile

âœ¨ Do it, Lady! âœ¨
""")
    except ValueError:
        print("âŒ Please enter valid numbers for start and end mile marks.")
        
#%% Leadville GPX Map Data

import gpxpy
import gpxpy.gpx
import os
os.chdir('/Users/tommywadelton/Downloads')
# Open and parse the GPX file
try:
    with open('visorando-2024-lt-100-run.gpx', 'r') as gpx_file:
        gpx = gpxpy.parse(gpx_file)
except FileNotFoundError:
    print("Error: GPX file not found.")
    exit()

# Access tracks, segments, and points
for track in gpx.tracks:
    for segment in track.segments:
        for point in segment.points:
            print(f'Point at ({point.latitude}, {point.longitude}) - Elevation: {point.elevation} - Time: {point.time}')
            
import pandas as pd

data = []
for track in gpx.tracks:
    for segment in track.segments:
        for point in segment.points:
            data.append({
                'latitude': point.latitude,
                'longitude': point.longitude,
                'elevation': point.elevation,
                'time': point.time
            })
df = pd.DataFrame(data)
print(df.head())

import folium

# Create a map centered at the first point of your track
if not df.empty:
    m = folium.Map(location=[df['latitude'].iloc[0], df['longitude'].iloc[0]], zoom_start=13)

    # Add the GPX track as a polyline
    points = list(zip(df['latitude'], df['longitude']))
    folium.PolyLine(points, color='blue', weight=2.5, opacity=1).add_to(m)

    # Save the map to an HTML file
    m.save('gpx_map.html')
    print("\nMap saved to gpx_map.html")
else:
    print("No data to plot.")
    
import plotly.express as px

if not df.empty:
    fig = px.line_mapbox(df, lat="latitude", lon="longitude", zoom=10,
                         mapbox_style="open-street-map", title="GPX Track")
    fig.show()
else:
    print("No data to plot.")
